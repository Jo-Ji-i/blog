---
title: 'React의 렌더링 과정 완전 정복'
date: '2025-03-02'
excerpt: 'React를 쓰다 보면 리렌더링이 너무 자주 일어나거나, 필요하지 않은 렌더링을 할 때가 있다. 이번 포스트에서 렌더링의 전체 흐름을 확실히 정리해본다..'
tags: ['React']
image: 'react.png'
category: 'react'
---

React를 쓰다 보면 리렌더링이 너무 자주 일어나거나, 필요하지 않은 렌더링을 할 때가 있다.

그런데 이 문제를 진짜 이해하려면 **React가 언제, 왜, 어떻게 렌더링을 하는지** 알아야 해결할 수 있다.

오늘은 바로 그 **렌더링의 전체 흐름**을 확실히 정리해본다.

## 렌더링(Rendering)이란?

React에서 **렌더링**은 간단히 말하면 “컴포넌트를 다시 계산해서 화면(UI)을 업데이트하는 과정”

조금 더 구체적으로 보면, 두 단계로 나뉜다.

1. **Render Phase (렌더 단계)**

    → JSX를 React 엘리먼트로 변환하고, 어떤 UI가 필요한지 계산하는 단계

2. **Commit Phase (커밋 단계)**

    → 실제로 DOM을 업데이트해서 브라우저 화면에 반영하는 단계

이걸 합쳐서 보통 “렌더링”이라고 부르죠.

## 렌더링이 일어나는 이유

React 컴포넌트는 **상태(state), props, context** 중 하나라도 바뀌면 리렌더링됩니다.

예를 들어

```jsx
function Counter() {
    const [count, setCount] = useState(0);

    return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

`setCount`가 호출되면 `count` 값이 변하고,

React는 상태가 바뀌어 **해당 컴포넌트와 자식 컴포넌트들을 다시 렌더링**합니다.

하지만 중요한 포인트는, 렌더링이 일어난다고 해서 곧바로 DOM이 다시 그려지는 건 아니다!

---

## Render Phase (렌더 단계)

렌더 단계에서는 실제 DOM에 접근하지 않는다.

이 단계의 핵심은 **Virtual DOM이다.**

React는 내부적으로 “새로운 Virtual DOM 트리”를 만들고,

이전 렌더링 때의 Virtual DOM과 비교(diffing)를 한다.

```jsx
// 렌더링 전
<div>Hello</div>

// 렌더링 후
<div>Hello, world!</div>

```

이 두 트리를 비교해서 “어디가 바뀌었는지” 계산하고,

그 차이(diff)만 실제 DOM에 반영하도록 준비한다.

---

## Commit Phase (커밋 단계)

Render Phase에서 “뭐가 바뀌었는지” 계산이 끝나면

React는 이제 진짜 DOM을 수정합니다.

-   변경된 DOM 노드를 추가, 삭제, 수정
-   `useLayoutEffect`, `useEffect` 등의 훅 실행

이게 **Commit Phase**, 즉 화면 반영 단계입니다.

여기서 비로소 브라우저가 “아, 이제 화면이 바뀌었구나” 하고 사용자에게 보여준다.

---

## 중요한 것은 “모든 리렌더링이 나쁜 건 아니다”

React는 **렌더링이 가볍다**는 전제하에 만들어졌기 때문에 렌더링 자체는 자주 일어나도 괜찮습니다.

다만, “불필요한 연쇄 렌더링” 이 문제가 되는 것이다.

예를 들어 부모 컴포넌트가 리렌더링될 때

자식 컴포넌트까지 덩달아 렌더링되는 경우!

이럴 때 쓰는 게 바로

-   `React.memo`
-   `useMemo`, `useCallback`
-   context 최적화 분리

이런 것들은 **불필요한 하위 렌더링을 막는 도구**일 뿐,

렌더링 자체를 없애는 게 아니라

진짜 필요한 컴포넌트만 다시 계산해서 효율적으로 구동하게 한다.

---

## 렌더링 관련 자주 하는 오해

| 오해                                       | 진실                                    |
| ------------------------------------------ | --------------------------------------- |
| `setState` 호출 시마다 DOM이 다시 그려진다 | 렌더 단계에서 계산만 다시 함            |
| `useRef` 값 바뀌면 렌더링된다              | state만 렌더링 트리거                   |
| 렌더링은 무조건 비싸다                     | React는 diff 계산을 최적화함            |
| React.memo는 모든 성능 문제의 해결책이다   | 상황에 따라 오히려 비용이 더 들 수 있음 |

---

## 결론

-   React의 렌더링은 **Render Phase**와 **Commit Phase**로 나뉘고,
-   상태나 props가 바뀌면 **다시 계산(render)** 한 뒤
-   바뀐 부분만 **실제 DOM에 커밋(commit)** 합니다.

> 렌더링은 곧 “화면을 새로 그리는 과정”이 아니라,
>
> “화면을 그릴지 말지 판단하는 과정”이다.
