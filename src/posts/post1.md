---
title: '전역 변수의 문제점'
date: '2025-02-10'
excerpt: '전역 변수의 문제점에 대해...'
tags: ['Next.js', 'Tailwind', 'React']
image: 'post1-cover.png'
category: 'FE'
---

# 전역 변수의 문제점

코드를 작성하면서 이 함수의 사용 범위에 따라 변수를 선언하고는 하는데,
직감적으로 객체나 변수는 전역에 노출되면 안될 것 같다고 생각했다.
그래서 정확히 왜 그래서는 안되는지 어떤 영향을 끼치는 지 자세히 알아보고 싶어졌다.
변수는 선언에 의해 생성 할당을 통해 값을 받음 생성되고 소멸되는 생명 주기가 존재한다.
변수는 자신이 선언된 위치에서 생성되고 소멸된다.
그래서 선언 위치가 아주 중요하다.
&nbsp;

### 변수의 생명주기

**지역변수라면, 함수가 종료할 대 소멸되어 생명 주기가 종료된다.**

```java
functuon func(){
	var x = 'local'
	console.log(x);
	return x;
}
func1();
console.log(x); // x is not defined
```

func 함수가 호출 될 때 지역변수 x 생성되고, 함수가 종료하면 자동으로 소멸된다.

결론적으로 **함수 내부에서 선언된 지역변수의 생명 주기 = 함수 생명 주기**

애초에 변수라는 것은 값을 저장하는 메모리 공간이다.
메모리 공간이 확보되고 해제되어 다시 메모리 풀에 반환 될 때 까지의 시점을 생명주기로 본다.

그렇다면, **전역 변수의 생명 주기는 어떻게 될까.**

보통 전역 객체는 코드 실행 이전에 먼저 생성되는 특수한 객체이다.
CSR 환경에서는 window / SSR 환경에서는 global 객체를 말한다.

만약 var로 선언한 **전역변수의 생명 주기는 전역 객체의 생명 주기와 같다.**

실행문이 없을 때까지 메모리를 반환하지 않는다.
&nbsp;

### 전역변수의 문제

벌써부터 이렇게 되면 어떤 문제들이 생길지 감이 온다.
대략적으로 메모리 누수와 변수가 저장하고 있는 값이 변질 될 우려가 있다는 것이다.

**암묵적 결합**

모든 코드가 전역변수를 참조하고 변경할 수 있는 암묵적 결합을 허용.
코드 유효 범위가 커지면서 가독성이 나빠지고 의도치 않게 값이 변경 될 수 있다.

**긴 생명 주기**

생명주기가 길다는 것은 메모리 리소스를 오래 소비한다는 것이다.
특히 var 키워드는 변수의 중복 선언을 허용하기 때문에 변수 이름이 중복될 수 있고 의도하지 않은 재할당이 우려된다.

**스코프 체인 상에서 종점에 존재**

변수를 검색 할 때 가장 마지막에 검색된다. 즉 검색 속도가 가장 느리다.
스코프에 대해 따로 공부 했지만 상당히 깊은 내용이라 추가 공부가 필요해 이는 다음 포스팅 주제가 될 것 같다.

**네임 스페이스 오염**

자바스크립트는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다.
다른 파일에서 동일한 이름의 전역변수나 전역 함수가 같은 스코프 내에 존재 할 경우 원하지 않는 결과가 나올 수 있다.

결론적으로 전역변수를 사용하는 것은 좋지 않다.
전역 변수를 사용하지 않는 코드 습관을 길러두자.
&nbsp;

### 전역 변수를 쓰지 않으려면...

**즉시 실행 함수 (IIFE)**

모든 코드를 즉시 실행 함수로 감싸서 모든 변수는 즉시 실행 함수의 지역변수로 만들자.
하지만 즉시 실행함수를 남용하면 메모리 낭비가 일어날 수 있다.

JS는 할당 없이 정의만 할 경우 전역 실행 컨텍스트의 temp=[] 내에 key-value를 추가하게 된다.
이 영역은 개발자가 접근 할 수 없어서 소스코드의 신뢰성에는 큰 도움이 되지만,
해당 공간에 계속 메모리가 쌓이게 되므로 적절히 사용하는 것이 좋다.

**네임스페이스 객체**

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역변수 처럼 사용하고 싶은 변수를 프로퍼티로 추가한다 .
해당 방법은 식별자 충돌을 방지할 수 있지만, 네임스페이스 자체는 전역에 할당 되긴 한다.

```java
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.person = {
  name: "Lee",
  address: "Seoul",
};

console.log(MYAPP.person.name); // Lee

```

**모듈 패턴**

클래스를 모방해서 관련 있는 변수와 함수를 모아서 즉시 실행 함수로 감싸 하나의 모듈을 만든다.
즉시 실행 함수로 감싸 지역을 만들고 그 안에 클래슬를 넣은 것이라고 생각하자.
JS의 클로저를 기반으로 동작해 전역변수 억제와 캡슐화 (프로퍼티와 메서드를 묶기)까지 구현할 수 있다.

```jsx
var counter = (function () {
    var number = 0; // 클로저로 인해서 전역변수가 아닌 지역변수가 되며 외부에서는 접근할 수 없다.

    return function () {
        // 외부로 공개할 함수나 메서드나 객체, 변수를 반환해준다.
        return ++number;
    };
})();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
console.log(counter.number); // undefined
```

**ES6 Module**

var 키워드가 전역으로 선언되지 않는다.
하나의 script 파일을 하나의 스코프를 갖을 수 있게 된다.

```
<script type='module' src='test.mjs'></script>
<script type='module' src='ES6ModuleTest.mjs'></script>`

```

**let, const 키워드**
var를 대체하기 위해 만들어진 키워드로 같은 역할을 한다.

let

-   호이스팅이 되긴 하지만 선언 시점보다 먼저 참조하면 에러 발생
-   전역 변수로 선언 해도 전역 객체의 프로퍼티로 존재하지 않음
-   재할당이 가능하다
-   모든 블록 스코프 안에서만 유효함

const

-   중복 선언 안됨, 보통 상수를 선언할 때 사용
-   const로 객체 선언 시, 객체의 프로퍼티는 생성, 변경, 삭제 등이 가능하다.

&nbsp;

## 결론

변수는 범위가 좁을 수록 좋다.
var 선언을 자제하고 상황에 맟게 let, const를 쓰는 것이 가장 간단한 방법이자 기본 같다.
추가로 선언식 프로그래밍 방식과 함께 모듈 패턴을 공부해봐도 될 것 같다.
