---
title: '동기와 비동기 비교'
date: '2025-03-01'
excerpt: '프론트엔드를 하다 보면 “비동기”라는 단어는 정말 자주 듣는다.
API 호출, setTimeout, 이벤트 핸들러, React의 useEffect까지 전부 비동기와 관련되어 있다...'
tags: ['Frontend', 'awiat', 'async', 'promise']
image: 'fe.png'
category: 'frontend'
---

프론트엔드를 하다 보면 “비동기”라는 단어는 정말 자주 듣는다.

API 호출, setTimeout, 이벤트 핸들러, React의 useEffect까지 전부 비동기와 관련되어 있다.

근데 막상 “동기와 비동기의 차이를 설명해보라”고 하면 대답이 애매한 경우가 많다.

이번 글에서는 프론트 개발자의 관점에서 **동기 / 비동기 개념**을 깔끔하게 정리해본다.

---

## 1. 동기(Synchronous)란?

**동기**는 말 그대로 “순서대로, 차례차례” 실행되는 흐름이다.

하나의 작업이 끝나야 다음 작업이 시작된다.

```jsx
console.log('1');
console.log('2');
console.log('3');
```

출력:

```
1
2
3

```

이게 전형적인 **동기적 실행**이다.

즉, 위에서부터 한 줄씩 실행되며, 이전 작업이 끝나야 다음 줄로 넘어간다.

이런 구조는 이해하기 쉽지만,

만약 중간에 오래 걸리는 작업이 있다면 프로그램이 멈춘 것처럼 느껴질 수 있다.

```jsx
console.log('1');
sleep(3000); // 3초 동안 멈춤
console.log('2');
```

이런 식이면 3초 동안 아무것도 안 하고 기다려야 한다.

문제는 **자바스크립트가 싱글 스레드**라는 점이다 — 즉, 한 번에 한 작업밖에 못 한다.

---

## 2. 비동기(Asynchronous)란?

**비동기**는 말 그대로 “기다리지 않는다.”

A 작업이 끝나지 않아도, B 작업을 먼저 실행할 수 있다.

예를 들어:

```jsx
console.log('1');

setTimeout(() => {
    console.log('2');
}, 1000);

console.log('3');
```

출력 결과:

```
1
3
2

```

왜 이런 결과가 나올까?

-   `setTimeout`은 Web API에 의해 **비동기 처리**로 등록된다.
-   자바스크립트 엔진은 `setTimeout`을 백그라운드로 넘기고 바로 다음 줄(`console.log("3")`)로 넘어간다.
-   1초 뒤, 큐(Event Queue)에 “2”를 찍는 콜백이 들어가고,
    메인 스레드가 한가해졌을 때 실행된다.

이게 바로 **Event Loop**의 작동 방식이다.

(이건 아래에서 좀 더 자세히 다룸)

---

## 3. 왜 프론트엔드에서는 비동기가 중요한가?

프론트엔드는 “사용자 경험”이 생명이다.

만약 브라우저가 서버에서 데이터를 받는 동안 완전히 멈춰버린다면,

화면이 멈춘 것처럼 보여서 UX가 최악이 된다.

예를 들어:

```jsx
const res = fetch('https://api.example.com/data');
console.log(res);
```

이렇게 하면 네트워크 응답을 기다리는 동안 코드 전체가 멈춘다.

그래서 JS는 `fetch()`를 비동기로 처리해서 응답이 오면 Promise로 결과를 반환한다.

즉,

**“화면은 계속 반응하면서, 데이터는 백그라운드에서 가져오는 구조”**

→ 이것이 비동기의 핵심이다.

---

## 4. 콜백, Promise, async/await의 등장 배경

비동기 처리는 결국 “언제 끝날지 모르는 작업”을 다루는 문제다.

이걸 해결하기 위해 JS는 진화해왔다.

| 시대   | 방식           | 특징                       |
| ------ | -------------- | -------------------------- |
| 초창기 | 콜백(callback) | 함수 중첩 많고 가독성 나쁨 |
| ES6    | Promise        | 체이닝으로 구조 개선       |
| ES8    | async/await    | 동기처럼 깔끔한 코드 가능  |

예를 들어, 다음 두 코드는 동일한 동작을 한다.

**Promise 버전**

```jsx
fetchData()
    .then((res) => parseData(res))
    .then((data) => render(data))
    .catch((err) => console.error(err));
```

**async/await 버전**

```jsx
async function main() {
    try {
        const res = await fetchData();
        const data = await parseData(res);
        render(data);
    } catch (err) {
        console.error(err);
    }
}
```

async/await가 등장하면서 “비동기”라는 복잡한 개념이 **코드 상에서는 거의 동기처럼 표현** 가능해졌다.

---

## 5. 이벤트 루프(Event Loop) 간단 이해

자바스크립트가 비동기를 처리하는 구조는 **이벤트 루프(Event Loop)** 덕분이다.

흐름은 이렇게 된다:

1. 모든 JS 코드는 **Call Stack(호출 스택)** 에서 실행된다.
2. 비동기 함수(setTimeout, fetch 등)는 **Web API**에 넘겨진다.
3. Web API에서 작업이 끝나면 **Task Queue**에 콜백이 등록된다.
4. Event Loop는 스택이 비었을 때 큐에서 콜백을 꺼내 실행한다.

즉, 자바스크립트 자체는 싱글 스레드지만,

브라우저(Web API)가 비동기 처리를 대신 맡아주는 구조다.

---

## 6. 동기 / 비동기 비교 요약

| 구분        | 동기(Synchronous)       | 비동기(Asynchronous)            |
| ----------- | ----------------------- | ------------------------------- |
| 실행 순서   | 순차 실행               | 병렬 실행 가능                  |
| 블로킹 여부 | 블로킹 (다음 코드 멈춤) | 논블로킹 (다음 코드 계속 실행)  |
| 예시        | 일반 함수 호출          | setTimeout, fetch, 이벤트리스너 |
| 장점        | 예측 가능, 단순         | 성능 효율, UX 개선              |
| 단점        | 느림, 멈춤 가능         | 코드 구조 복잡                  |

---

## 7. 프론트 개발에서 자주 쓰이는 비동기 예시

-   `fetch()` API 호출
-   `setTimeout`, `setInterval`
-   React의 `useEffect` 내부 비동기 요청
-   이벤트 핸들러 (`onClick`, `onSubmit` 등)
-   WebSocket이나 SSE 같은 실시간 통신

이런 모든 기능들이 결국 비동기 위에서 돌아간다.

그래서 비동기의 개념을 제대로 이해하지 못하면

“왜 이 타이밍에 state가 안 바뀌지?” 같은 문제에서 헤어나오기 어렵다.

---

## 8. 마무리

정리하자면:

-   **동기:** 한 줄씩 실행, 기다림
-   **비동기:** 기다리지 않고 나중에 결과를 받음
-   **Promise / async/await:** 비동기를 깔끔하게 표현하는 방법
-   **Event Loop:** 자바스크립트의 비동기 핵심 메커니즘

프론트엔드 개발에서 비동기는 “선택 사항”이 아니라 “기본 구조”다.

JS의 실행 순서와 비동기 처리 원리를 정확히 이해하면,

렌더링 타이밍, 데이터 fetching, 상태 업데이트 타이밍 같은 부분들이 명확하게 보인다.

---
